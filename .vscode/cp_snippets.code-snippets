{
	// Place your VsCode workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Segment Tree": {
		"prefix": "_seg",
		"body": [
		  "//START seg_tree",
		  "struct segment",
		  "{",
		  "    long long sum_value;",
		  "    bool def = false;",
		  "};",
		  "",
		  "class Stree",
		  "{",
		  "private:",
		  "    segment combine(segment left, segment right)",
		  "    {",
		  "        if (left.def) return right;",
		  "        if (right.def) return left;",
		  "",
		  "        segment res;",
		  "        res.def = false;",
		  "",
		  "        res.sum_value = left.sum_value + right.sum_value;",
		  "",
		  "        return res;",
		  "    }",
		  "",
		  "    Stree* L = NULL;",
		  "    Stree* R = NULL;",
		  "    int ss, se;",
		  "    int mid;",
		  "    bool isOut(int qs, int qe)",
		  "    {",
		  "        return (ss > qe || se < qs);",
		  "    }",
		  "    bool isIn(int qs, int qe)",
		  "    {",
		  "        return (ss >= qs && se <= qe);",
		  "    }",
		  "    void clear()",
		  "    {",
		  "        if (ss == se) return;",
		  "",
		  "        L->clear();",
		  "        R->clear();",
		  "",
		  "        delete L;",
		  "        delete R;",
		  "",
		  "        ss = se = mid = 0;",
		  "    }",
		  "",
		  "    void push()",
		  "    {",
		  "        if (!to_push) return;",
		  "",
		  "        val.sum_value += (long long)(se - ss + 1) * lazy;",
		  "",
		  "        if (ss != se)",
		  "        {",
		  "            L->to_push = R->to_push = true;",
		  "            L->lazy += lazy;",
		  "            R->lazy += lazy;",
		  "        }",
		  "        lazy = 0;",
		  "        to_push = false;",
		  "    }",
		  "    bool to_push = false;",
		  "    long long lazy = 0;",
		  "    segment val;",
		  "public:",
		  "",
		  "    Stree(int SS, int SE)",
		  "    {",
		  "        ss = SS;",
		  "        se = SE;",
		  "        mid = (ss + se) >> 1;",
		  "        val.def = false;",
		  "    }",
		  "    ~Stree() { clear(); }",
		  "",
		  "    void buildTree()",
		  "    {",
		  "        if (ss == se)",
		  "        {",
		  "            val.sum_value = 0;",
		  "            return;",
		  "        }",
		  "        if (!L) L = new Stree(ss, mid);",
		  "        if (!R) R = new Stree(mid + 1, se);",
		  "        L->buildTree();",
		  "        R->buildTree();",
		  "",
		  "        val = combine(L->val, R->val);",
		  "    }",
		  "",
		  "    segment getVal(int q)",
		  "    {",
		  "        push();",
		  "        if (ss == se) return val;",
		  "        if (mid >= q) return L->getVal(q);",
		  "        return R->getVal(q);",
		  "    }",
		  "    segment getRangeVal(int qs, int qe)",
		  "    {",
		  "        push();",
		  "        if (isOut(qs, qe))",
		  "        {",
		  "            segment def;",
		  "            def.def = true;",
		  "            return def;",
		  "        }",
		  "        if (isIn(qs, qe)) return val;",
		  "        return combine(L->getRangeVal(qs, qe), R->getRangeVal(qs, qe));",
		  "    }",
		  "    void increaseRange(int qs, int qe, long long a)",
		  "    {",
		  "        push();",
		  "        if (isOut(qs, qe)) return;",
		  "        if (ss >= qs && se <= qe)",
		  "        {",
		  "            to_push = true;",
		  "            lazy += a;",
		  "            push();",
		  "            return;",
		  "        }",
		  "",
		  "        L->increaseRange(qs, qe, a);",
		  "        R->increaseRange(qs, qe, a);",
		  "",
		  "        val = combine(L->val, R->val);",
		  "    }",
		  "",
		  "};",
		  "//END seg_tree"
		],
		"description": "Segment Tree"
	  },
	"Unique": {
		"prefix": "_unique",
		"body": [
		  "$1.resize(distance($1.begin(),unique($1.begin(),$1.end())));",
		  "int n_new = $1.size();"
		],
		"description": "Unique"
	  },
	"For Loop": {
		"prefix": "_for",
		"body": [
		  "for(auto& ele : $1)",
		  "{",
		  "    $2",
		  "}",
		],
		"description": "For Loop"
	  },
	  "New Line": {
		"prefix": "_nline",
		"body": [
		  "cout << \"\\n\";"
		],
		"description": "New Line"
	  },
	  "New Value": {
		"prefix": "_val",
		"body": [
		  "int val;",
		  "cin >> val;"
		],
		"description": "New Value"
	  },
	  "Count If": {
		"prefix": "_count",
		"body": [
		  "count_if($1.begin(), $1.end(), [&](auto &ele){ return (${2:condition}); })"
		],
		"description": "Count If"
	  },
	  "Accumulate With": {
		"prefix": "_accum",
		"body": [
		  "accumulate($1.begin(), $1.end(), ${2:initial value}, [&](auto &ele1, auto &ele2){ return (ele1 ${3:operator} ele2); })"
		],
		"description": "Count If"
	  },
	  "Preffix Sum": {
		"prefix": "_pref",
		"body": [
		  "vector<long long> pref($1.size());",
		  "partial_sum($1.begin(),$1.end(),pref.begin());",
		  "auto pref_sum = [&](int l,int r) -> long long",
		  "{",
		  "    if(l > r) return 0;",
		  "    if(r >= $1.size()) r = $1.size() - 1;",
		  "    if(l <= 0) return pref[r];",
		  "    return pref[r] - pref[l-1];",
		  "};"
		],
		"description": "Preffix Sum"
	  },
	  "Binary Search": {
		"prefix": "_bin",
		"body": [
		  "auto check = [&](ll md) -> bool",
		  "{",
		  "};",
		  "",
		  "ll low = 0, high = 1e15, mid, ans = 0;",
		  "while(low <= high)",
		  "{",
		  "    mid = (low + high) >> 1;",
		  "    if(check(mid))",
		  "    {",
		  "        ans = mid;",
		  "        low = mid + 1;",
		  "    }",
		  "    else high = mid - 1;",
		  "}"
		],
		"description": "Binary Search"
	  },
	  "NCR_MODM": {
		"prefix": "_ncr",
		"body": [
		  "// set MAX_N and call fact_init();",
		  "long long factorial[MAX_N];",
		  "void fact_init()",
		  "{",
		  "    factorial[0] = factorial[1] = 1;",
		  "    for (int i = 2; i < MAX_N; i++)",
		  "        factorial[i] = (factorial[i - 1] * i) % MOD;",
		  "}",
		  "",
		  "// returns (a^n) % MOD",
		  "long long power(long long a, long long n)",
		  "{",
		  "    long long res = 1;",
		  "    while (n)",
		  "    {",
		  "        if (n & 1)",
		  "            res = (res * a) % MOD;",
		  "        a = (a * a) % MOD;",
		  "        n = n >> 1;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "// returns (nCr) %MOD",
		  "long long nCr(int n, int r)",
		  "{",
		  "    if (r > n || r < 0)",
		  "        return 0;",
		  "    if (n == r || r == 0)",
		  "        return 1;",
		  "    return ((factorial[n] * power(factorial[r], MOD - 2)) % MOD * power(factorial[n - r], MOD - 2)) % MOD;",
		  "}",
		  "",
		  "// note: MAX_N >= 2*n",
		  "long long catalan_no(int n)",
		  "{",
		  "    return (nCr(2 * n, n) * power(n + 1, MOD - 2)) % MOD;",
		  "}",
		  ""
		],
		"description": "NCR_MODM"
	  }

}