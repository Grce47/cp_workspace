{
	"Graph": {
		"prefix": "_tree",
		"body": [
		  "struct Graph",
		  "{",
		  "    int n;",
		  "    vector<vector<int>> tree;",
		  "    Graph(int _n) : n(_n), tree(_n) {}",
		  "    inline void take_input()",
		  "    {",
		  "        for (int i = 0; i < n - 1; i++)",
		  "        {",
		  "            int u, v;",
		  "            cin >> u >> v; u--; v--;",
		  "            tree[u].push_back(v);",
		  "            tree[v].push_back(u);",
		  "        }",
		  "    }",
		  "};"
		],
		"description": "Graph"
	  },
	"Segment Tree": {
		"prefix": "_seg",
		"body": [
		  "//START seg_tree",
		  "struct segment",
		  "{",
		  "    long long sum_value;",
		  "    bool def = false;",
		  "};",
		  "",
		  "class Stree",
		  "{",
		  "private:",
		  "    segment combine(segment left, segment right)",
		  "    {",
		  "        if (left.def) return right;",
		  "        if (right.def) return left;",
		  "",
		  "        segment res;",
		  "        res.def = false;",
		  "",
		  "        res.sum_value = left.sum_value + right.sum_value;",
		  "",
		  "        return res;",
		  "    }",
		  "",
		  "    Stree* L = NULL;",
		  "    Stree* R = NULL;",
		  "    int ss, se;",
		  "    int mid;",
		  "    bool isOut(int qs, int qe)",
		  "    {",
		  "        return (ss > qe || se < qs);",
		  "    }",
		  "    bool isIn(int qs, int qe)",
		  "    {",
		  "        return (ss >= qs && se <= qe);",
		  "    }",
		  "    void clear()",
		  "    {",
		  "        if (ss == se) return;",
		  "",
		  "        L->clear();",
		  "        R->clear();",
		  "",
		  "        delete L;",
		  "        delete R;",
		  "",
		  "        ss = se = mid = 0;",
		  "    }",
		  "",
		  "    void push()",
		  "    {",
		  "        if (!to_push) return;",
		  "",
		  "        val.sum_value += (long long)(se - ss + 1) * lazy;",
		  "",
		  "        if (ss != se)",
		  "        {",
		  "            L->to_push = R->to_push = true;",
		  "            L->lazy += lazy;",
		  "            R->lazy += lazy;",
		  "        }",
		  "        lazy = 0;",
		  "        to_push = false;",
		  "    }",
		  "    bool to_push = false;",
		  "    long long lazy = 0;",
		  "    segment val;",
		  "public:",
		  "",
		  "    Stree(int SS, int SE)",
		  "    {",
		  "        ss = SS;",
		  "        se = SE;",
		  "        mid = (ss + se) >> 1;",
		  "        val.def = false;",
		  "    }",
		  "    ~Stree() { clear(); }",
		  "",
		  "    void buildTree()",
		  "    {",
		  "        if (ss == se)",
		  "        {",
		  "            val.sum_value = 0;",
		  "            return;",
		  "        }",
		  "        if (!L) L = new Stree(ss, mid);",
		  "        if (!R) R = new Stree(mid + 1, se);",
		  "        L->buildTree();",
		  "        R->buildTree();",
		  "",
		  "        val = combine(L->val, R->val);",
		  "    }",
		  "",
		  "    segment getVal(int q)",
		  "    {",
		  "        push();",
		  "        if (ss == se) return val;",
		  "        if (mid >= q) return L->getVal(q);",
		  "        return R->getVal(q);",
		  "    }",
		  "    segment getRangeVal(int qs, int qe)",
		  "    {",
		  "        push();",
		  "        if (isOut(qs, qe))",
		  "        {",
		  "            segment def;",
		  "            def.def = true;",
		  "            return def;",
		  "        }",
		  "        if (isIn(qs, qe)) return val;",
		  "        return combine(L->getRangeVal(qs, qe), R->getRangeVal(qs, qe));",
		  "    }",
		  "    void increaseRange(int qs, int qe, long long a)",
		  "    {",
		  "        push();",
		  "        if (isOut(qs, qe)) return;",
		  "        if (ss >= qs && se <= qe)",
		  "        {",
		  "            to_push = true;",
		  "            lazy += a;",
		  "            push();",
		  "            return;",
		  "        }",
		  "",
		  "        L->increaseRange(qs, qe, a);",
		  "        R->increaseRange(qs, qe, a);",
		  "",
		  "        val = combine(L->val, R->val);",
		  "    }",
		  "",
		  "};",
		  "//END seg_tree"
		],
		"description": "Segment Tree"
	  },
	"Unique": {
		"prefix": "_unique",
		"body": [
		  "$1.resize(distance($1.begin(),unique($1.begin(),$1.end())));",
		  "int n_new = $1.size();"
		],
		"description": "Unique"
	  },
	"For Loop": {
		"prefix": "_for",
		"body": [
		  "for(auto& ele : $1)",
		  "{",
		  "    $2",
		  "}",
		],
		"description": "For Loop"
	  },
	  "DFS": {
		"prefix": "_dfs",
		"body": [
		  "void dfs(int cur, int par)",
		  "{",
		  "    for(auto &ch : tree[cur])",
		  "    {",
		  "        if(ch == par) continue;",
		  "    }",
		  "}"
		],
		"description": "DFS"
	  },
	  "New Line": {
		"prefix": "_nline",
		"body": [
		  "cout << \"\\n\";"
		],
		"description": "New Line"
	  },
	  "New Value": {
		"prefix": "_val",
		"body": [
		  "int val;",
		  "cin >> val;"
		],
		"description": "New Value"
	  },
	  "Count If": {
		"prefix": "_countif",
		"body": [
		  "count_if($1.begin(), $1.end(), [&](auto &ele){ return (${2:condition}); })"
		],
		"description": "Count If"
	  },
	  "Count": {
		"prefix": "_count",
		"body": [
		  "count($1.begin(), $1.end(), ${2:element})"
		],
		"description": "Count If"
	  },
	  "Accumulate With": {
		"prefix": "_accum",
		"body": [
		  "accumulate($1.begin(), $1.end(), ${2:initial value}, [&](auto &ele1, auto &ele2){ return (ele1 ${3:operator} ele2); })"
		],
		"description": "Accummulator with custom function"
	  },
	  "Range Maker": {
		"prefix": "_range",
		"body": [
		  "vector<pair<int, int>> range;",
		  "for (int i = 0; i < $1.size(); i++)",
		  "{",
		  "    int len = 0;",
		  "    for (int j = i; j < $1.size(); j++)",
		  "    {",
		  "        if ($1[i] != $1[j]) break;",
		  "        len++;",
		  "    }",
		  "    range.push_back(make_pair(i, len));",
		  "    i += len - 1;",
		  "}"
		],
		"description": "Range Maker"
	  },
	  "Eratosthenes Sieve": {
		"prefix": "_prime",
		"body": [
		  "bitset<MAX_N> isprime;",
		  "void eratosthenes_sieve()",
		  "{",
		  "\tisprime.set();",
		  "\tisprime[0] = isprime[1] = 0;",
		  "\tfor (int i = 4; i < MAX_N; i += 2)",
		  "\t\tisprime[i] = 0;",
		  "\tfor (int i = 3; i * i < MAX_N; i += 2)",
		  "\t\tif (isprime[i])",
		  "\t\t\tfor (int j = i * i; j < MAX_N; j += i * 2)",
		  "\t\t\t\tisprime[j] = 0;",
		  "}"
		],
		"description": "Eratosthenes Sieve"
	  },
	  "Preffix Sum": {
		"prefix": "_pref",
		"body": [
		  "vector<long long> pref($1.size());",
		  "partial_sum($1.begin(),$1.end(),pref.begin());",
		  "auto pref_sum = [&](int l,int r) -> long long",
		  "{",
		  "    if(l > r) return 0;",
		  "    if(r >= $1.size()) r = $1.size() - 1;",
		  "    if(l <= 0) return pref[r];",
		  "    return pref[r] - pref[l-1];",
		  "};"
		],
		"description": "Preffix Sum"
	  },
	  "Binary Search": {
		"prefix": "_bin",
		"body": [
		  "auto check = [&](ll md) -> bool",
		  "{",
		  "};",
		  "",
		  "ll low = 0, high = 1e15, mid, ans = 0;",
		  "while(low <= high)",
		  "{",
		  "    mid = (low + high) >> 1;",
		  "    if(check(mid))",
		  "    {",
		  "        ans = mid;",
		  "        low = mid + 1;",
		  "    }",
		  "    else high = mid - 1;",
		  "}"
		],
		"description": "Binary Search"
	  },
	  "NCR_MOD_M": {
		"prefix": "_ncr",
		"body": [
		  "// returns (a^n) % MOD",
		  "long long power(long long a, long long n)",
		  "{",
		  "    long long res = 1;",
		  "    while (n)",
		  "    {",
		  "        if (n & 1)",
		  "            res = (res * a) % MOD;",
		  "        a = (a * a) % MOD;",
		  "        n = n >> 1;",
		  "    }",
		  "    return res;",
		  "}",
		  "",
		  "// set MAX_N and call fact_init();",
		  "long long factorial[MAX_N], inv_factorial[MAX_N];",
		  "void fact_init()",
		  "{",
		  "    factorial[0] = factorial[1] = 1;",
		  "    for (int i = 2; i < MAX_N; i++)",
		  "        factorial[i] = (factorial[i - 1] * i) % MOD;",
		  "",
		  "    for (int i = 0; i < MAX_N; i++)",
		  "        inv_factorial[i] = power(factorial[i], MOD - 2);",
		  "}",
		  "",
		  "// returns (nCr) %MOD",
		  "long long nCr(int n, int r)",
		  "{",
		  "    if (r > n || r < 0)",
		  "        return 0;",
		  "    if (n == r || r == 0)",
		  "        return 1;",
		  "    return ((factorial[n] * inv_factorial[r]) % MOD * inv_factorial[n - r]) % MOD;",
		  "}",
		  "",
		  "// note: MAX_N >= 2*n",
		  "long long catalan_no(int n)",
		  "{",
		  "    return (nCr(2 * n, n) * power(n + 1, MOD - 2)) % MOD;",
		  "}",
		  ""
		],
		"description": "NCR_MOD_M"
	  },
	  "Modular Arithmetic": {
		"prefix": "_mod",
		"body": [
		  "long long mod_add(const long long a, const long long b)",
		  "{",
		  "    return (a + b) % MOD;",
		  "}",
		  "long long mod_sub(const long long a, const long long b)",
		  "{",
		  "    return (a - b + MOD) % MOD;",
		  "}",
		  "long long mod_mult(const long long a, const long long b)",
		  "{",
		  "    return (a * b) % MOD;",
		  "}",
		  "long long mod_div(const long long a, long long b)",
		  "{",
		  "    long long res = 1, _n = MOD - 2;",
		  "    while (_n)",
		  "    {",
		  "        if (_n & 1)",
		  "            res = (res * b) % MOD;",
		  "        b = (b * b) % MOD;",
		  "        _n >>= 1;",
		  "    }",
		  "    return (a * res) % MOD;",
		  "}"
		],
		"description": "Modular Arithmetic"
	  }

}